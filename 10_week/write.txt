포인터

데이터가 있는 곳.
1. 메인메모리 dram
2. 캐시 메모리 sram
3. 레지스터 cpu 속에 있다.
4. 하드 디스크
이중 cpu가 상호작용하는 곳은 1부터 3.

주소를 사용하는 방식.
1. 절대주소,
2. 상대주소
3. 가상주소
포인터를 통해서 가리키는 것은 가상 주소. 자료형 이후에 나오는 *는 주소를 뜻한다.
&를 쓸 때 자료형 없이 나오는 &도 주소이다.


모든 주소는 웬만해서 8바이트로 고정이다.
왜냐, 우리가 쓰는 램(메인 메모리)에 접근할 때 주소가 쓰이는데,
끽해봐야 8기가, 16기가니까, 그 모든 공간에 접근하기 위해서 주소를 쓴다.
이 주소들을 표현하는 데에는 64비트만으로 충분하다.
128비트가 필요하려면 요타 바이트 정도까지 메인 메모리가 확장되어야 하는데.. 그럴 일은 앞으로 없을 듯.
아무튼 그래서 현재 사용하는 모든 컴퓨터에서 주소는 전부 8바이트로 고정되어 있다. 우리가 쓰는 x86이라는 것이 이걸 말한다.

주소를 초기화할 때는 NULL을 사용한다.

우리가 출력으로보는 주소는 가상 메모리 주소이다. 실행할 때마다 바뀌는 것을 보면 확인할 수 있다.
흔히 텍스트, 데이터, 힙, 스택을 말하는 그것은 죄다 가상 주소이다.
cpu는 메모리램의 도움을 받아 해당 주소에 대한 접근을 하는 것이 가능하다. os가 핸들랑해준다.
참고로 아두이노나, 임베디드에서 사용하는 주소는 절대주소이다.


메모리는 바이트단위로 주소를 매긴다.
포인터도 변수.


포인터를 쓸 때 초기화를 되도록 해주자.
그냥 포인터 선언한 후에 해당 값을 참조하려고 한다면?
이포인터는 쓰레기값을 주소로 가진다.

포인터에 대해 증감 연산이 가능한데, 이때 자료형에 맞게 점프하는 위치가 바뀐다.
char에 대해 하면 +1 이 되고 int면 +4, double이면 8씩 된다.
증감연산할 때 한번에 읽는 단위씩 이동는 것이다.

*p++를 하면 증가를 먼저하고 참조한다.
즉 위치이동을 하는 꼴.
괄호를 써서 해야 값증가를 시킬 수 있다.

값에 의한 호출과 참조에 의한 호출이 있다.
값에 의한 호출은 나중에 함수를 나왔을 때 아무것도 바뀌지 않는다.
그러나 참조를 통해 호출할 경우에는 실제 값에 영향을 준다.

배열은 그 자체로 주소.
배열은 차원을 늘릴 수 있으나 실질적으로 데이터는 1차원으로 이뤄져 있다.
베열의 경우 선언할 때 초기화를 같이 하면서 끝값만 넣어두면 알아서 정해진다.
s[][5] = {1,2,3,4,5}이렇게 되어 있다면?
s[1][5]가 된다는 것이다. 참고로 개수를 맞춰줄 필요는 없다.
넉넉하게 공간을 확보하고 나머지 공간에 0을 채워주는 방식으로 동작한다.
넘파이 reshape(-1)쓰는 것과 비슷하게 생각하면 될 것 같다.

배열은 변수가 아니라 상수라 주소를 변경하느 것이 불가능하다.